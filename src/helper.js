export const isWinner = (gameBoard, currentMove, currentPlayer) =>{
   //updates, effectively mutating the state
    let board = [...gameBoard];
    board[currentMove] = currentPlayer;

   //winning combinations
    const winLines = [
        [0,1,2,3],
        [4,5,6,7],
        [8,9,10,11],
        [12,13,14,15],
        [0,4,8,12],
        [1,5,9,13],
        [2,6,10,14],
        [3,7,11,15],
        [0,5,10,15],
        [3,6,9,12],
    ];

    //Check player if the player is in winning positions
    for(let i=0; i< winLines.length; i++){
        //set these values to the winning positions
        const [c1, c2, c3, c4] = winLines[i];

        //check the winning postions has the same player
        if(board[c1] > 0 && 
            board[c1] ===  board[c2] &&
            board[c2] ===  board[c3] &&
            board[c3] ===  board[c4])
        {
            return true;
        }
    }
    return false;
}

export const isDraw = (gameBoard, currentMove, currentPlayer) => {
    let board = [...gameBoard];
    board[currentMove] = currentPlayer;

    // Count the number of empty spaces (denoted by 0)
    // (x===0) checks the board[x] if equals to 0, this will return true(1) or false(0)
    let count = board.reduce((n, x) => n + ( x === 0 ), 0);
    console.log(`count ${count}`);

    // Return true if the game is a draw (no more empty spaces left)
    return count === 0;
}

 //generate a random valid move 
const getRandomComputerMove = (gameBoard) => { 
    let validMoves = [];
    for(let i = 0; i < gameBoard.length; i++){
        //push if the gameboard value is 0 (no player)
        if(gameBoard[i]=== 0){
            validMoves.push(i);
        }
    }
    let rndMove = Math.floor(Math.random() * validMoves.length);
    return validMoves[rndMove];
}

const getPosition = (gameBoard, moveChecks) =>{
    //go through the moveChecks
    for(let check = 0; check < moveChecks.length; check++){
        //increment by no of step of moveChecks, maximun increment based on the max of the moveChecks
        for(let i = 0;  i < moveChecks[check].max; i += moveChecks[check].step){
            //gets the gameboard value, and create string called "series"
            let series = gameBoard[i + moveChecks[check].indexes[0]].toString() +
            gameBoard[i + moveChecks[check].indexes[1]].toString() +
            gameBoard[i + moveChecks[check].indexes[2]].toString() +
            gameBoard[i + moveChecks[check].indexes[3]].toString() ;

            //if the "series" matches these patterns below, return id of the optimal move
            switch(series){
                case "1110":
                case "2220":
                    return i + moveChecks[check].indexes[3];
                case "1101":
                case "2202":   
                    return i + moveChecks[check].indexes[2];
                case "1011":
                case "2022":   
                    return i + moveChecks[check].indexes[1];
                case "0111":
                case "0222":   
                    return i + moveChecks[check].indexes[0];
                default:
            }
        }
    } 
    //if the "series" doesn't match any of the switch cases return -1
    return -1;
};

export const getComputerMove = (gameBoard) =>{
    //pattern of checks, pattern to able to check the whole gameboard
    let moveChecks = [
        //check vertically
        {
            indexes: [0,4,8,12],
            max: 4,
            step: 1,
        },
        //check horizontally
        {
            indexes: [0,1,2,3],
            max: 16,
            step: 4,
        },
        //check diagonally
        {
            indexes: [0,5,10,15],
            max: 16,
            step: 16,
        },
        //check diagonally
        {
            indexes: [3,6,9,12],
            max: 16,
            step: 16,
        },
    ];

    let position = getPosition(gameBoard, moveChecks);
    //return "position" if greater and equal to 0
    if(position > -1) return position;
    //if not, return an id generated by the "getRandomComputerMove()"
    return getRandomComputerMove(gameBoard);

}